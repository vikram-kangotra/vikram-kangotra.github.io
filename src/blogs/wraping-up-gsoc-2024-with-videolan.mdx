---
title: "Wrapping up GSoC 2024 with VideoLan"
publishedAt: "2024-08-19"
excerpt: "As my Google Summer of Code 2024 journey comes to an end, I’m excited to share my experiences with VideoLan. This summer, I focused on adding Rust support to VLC and creating a plugin system using Wasmer to enable WebAssembly plugins. It’s been a fantastic ride, filled with learning and collaboration. A huge thanks to my mentor and the VideoLan team for their support. Looking forward to continuing my open-source adventures!"
---

<div className='flex justify-center'>
    <div className='flex justify-center'>
        <Image src='/assets/gsoc.png' width='250' height='250' layout='fixed' />
    </div>
    <div className='flex justify-center'>
        <Image src='/assets/vlc.png' width='250' height='250' layout='fixed' />
    </div>
</div>

Participating in Google Summer of Code (GSoC) 2024 with VideoLan has been an incredibly rewarding experience. This summer, I had the opportunity to work on a project that aimed to bring the power of WebAssembly (Wasm) to VLC by developing a plugin system using Rust and Wasmer. The goal was to enhance VLC’s extensibility by enabling WebAssembly plugins, potentially setting the stage for replacing the existing Lua scripting system in the future. Throughout this journey, I’ve gained valuable insights into Rust, WebAssembly, and the VLC codebase, all while collaborating with an amazing team of developers. I’m thrilled to share my journey and the progress made during this exciting project.

## Project Scope

- **Rust Integration**
   
   The initial step was to add Rust support to VLC, ensuring seamless integration within the codebase. This work built upon the foundational Rust work done by [Loic](https://code.videolan.org/videolan/vlc/-/merge_requests/2738), which significantly accelerated progress. Without Loic's initial contributions, it would have taken considerably more time to reach the level of integration achieved. This groundwork was essential for the subsequent development of the Wasm Plugin Manager.

- **Wasm Plugin Manager Development**

    The core focus was on creating a manager capable of loading and handling WebAssembly plugins. The aim was to replicate and eventually extend the Lua scripting functionality, allowing users to develop plugins in any language that compiles to WebAssembly.

- **Interface and Extension Module Implementation**

    To manage Wasm plugins, both an interface module and an extension module were necessary. The interface module provided the necessary hooks for Wasm plugins to interact with VLC. The extension module, on the other hand, was required to handle the specifics of the extension lifecycle and integration. This involved identifying the required functions and capabilities for these modules, using the Lua extension launcher as a reference. The approach was to start with a minimal, testable set of features and expand from there.

- **Testing and Iteration**

    Rigorous testing was crucial to ensure stability and functionality. The process began with simple tests using small WebAssembly (WASM) files, which allowed us to verify that each feature worked as intended within VLC. As the project progressed, the scope of testing expanded to cover more complex scenarios and edge cases to ensure comprehensive validation of all features.

## Merge Requests

Several key merge requests (MRs) were made to enhance VLC’s functionality and integrate Rust with WebAssembly (Wasm). This section provides an overview of these MRs, including those that have been accepted and those still in progress. MRs requiring further details will be discussed in depth later.

### 1. extensions_manager: Introduce typed callbacks for extensions_manager

- [View MR Details](https://code.videolan.org/videolan/vlc/-/merge_requests/5475)

**Status:** <span style={{color: '#4ade80'}}>Merged</span>

This MR introduced typed callbacks as an alternative to the variadic argument `pf_control`.

**Rationale:**

> The goal of introducing typed callbacks is to have a safer interface to plug into, moving away from the complexities surrounding `va_list`. The current approach with `va_list` is prone to errors due to compiler-specific implementations, limited support in safer languages, and the need for `va_arg` everywhere. Typed callbacks allow programming languages without `va_list` support to still implement these callbacks.

### 2. [GSoC 2024] Add WebAssembly Plugin Support and Integrate with Latest Rust Support Changes 
- [View MR Details](https://code.videolan.org/videolan/vlc/-/merge_requests/5528)

**Status:** <span style={{color: '#fb923c'}}>Draft</span>

This MR introduces WebAssembly Plugin System support using [Wasmer](https://github.com/wasmerio/wasmer) in Rust. The Rust work is derived from [Loic's rust-for-vlc branch](https://code.videolan.org/loic/vlc/-/tree/rust-for-vlc?ref_type=heads).

**Detailed Changes:**
1. **WebAssembly Plugin Implementation:**
   - Added core functionality for WebAssembly plugins using Wasmer.
   - Integrated WebAssembly plugin loading, execution processes, and interactions.
2. **Rust Support Integration:**
   - Merged the latest master branch changes, including Loic's commits for Rust support.

**Motivation:**
- Extend the capabilities of our system by incorporating WebAssembly plugins.
- Ensure seamless integration of the new WebAssembly functionality with Rust support enhancements.

### 3. [GSoC 2024] extensions: Add Locking and Access Functions for Managing Extension Array 
- [View MR Details](https://code.videolan.org/videolan/vlc/-/merge_requests/5777)

**Status:** <span style={{color: '#fb923c'}}>Draft</span>

This MR introduces new functions for synchronization and access control in the extension manager. The updates address:

- **Ownership Flexibility:** When the extension manager is instantiated from C, it directly owns the extensions. If instantiated from Rust or another language, that language retains ownership, which can result in the extension array being null. This flexibility allows Rust code to manage and own the extensions while ensuring compatibility with existing C code.
  
- **Synchronization and Access Control:** The new functions provide necessary synchronization and access control mechanisms to manage the extension array consistently, regardless of the instantiating language.

### 4. macosx: Fix potential deadlock in VLCExtensionsManager
- [View MR Details](https://code.videolan.org/videolan/vlc/-/merge_requests/5787)

**Status:** <span style={{color: '#4ade80'}}>Merged</span>

Ensured mutex is unlocked if the extension index exceeds the array size to prevent deadlock.

### 5. rust: cargo: Fix Build Command Error
- [View MR Details](https://code.videolan.org/videolan/vlc/-/merge_requests/5815)

**Status:** <span style={{color: '#4ade80'}}>Merged</span>

Fixed a build issue related to the cargo command.

### 6. rust: Add vlcrs-core Crate and Abstractions for vlc_object_t
- [View MR Details](https://code.videolan.org/videolan/vlc/-/merge_requests/5896)

**Status:** <span style={{color: '#fb923c'}}>Pending</span>

This Merge Request adds the `vlcrs-core` crate, which helps create safe ways to work with VLC's C functions and definitions. This crate makes it easier to use VLC features in Rust without directly dealing with unsafe C code.

It also includes Rust abstractions for `vlc_object_t`, making it simpler and safer to handle VLC objects in Rust.

## Technical Detail

In this section, I'll dive into the technical aspects of the project and how various challenges were addressed.

The work began by branching from the `master` branch, but since the Rust integration hadn't yet been merged into the master, I needed to rebase Loic's Rust work onto my new branch. This was one of the reasons why the Merge Request included both the WebAssembly work and the Rust integration.

At this stage, a key decision revolved around how to generate the FFI bindings to C/C++. We had two options:

1. Use bindgen: This tool automatically generates the Rust FFI bindings.
2. Manual Binding: Writing the bindings manually to maintain more control over the integration.

After extensive discussions, it was decided that manually written bindings would be more beneficial in the long run. This approach, although more labor-intensive upfront, offered greater flexibility and precision, ensuring that the integration would be robust and adaptable as the project evolved. With this decision made, the work officially kicked off.

### Interface and Extension Modules

The first task was to create the Interface and Extension modules. Interfaces are how you interact with the VLC media player. Creating the Interface module was relatively straightforward at this stage, as there wasn't much code to write. We needed to develop the Rust FFI for the interface and wrap it in a way that ensured safety in Rust. The implementation details can be found [here](https://code.videolan.org/vikram-kangotra/vlc/-/blob/wasm-plugin-system/src/rust/vlcrs-submodules/src/interface.rs?ref_type=heads). With this in place, defining an interface module in Rust became a straightforward task.

```rust
use vlcrs_core::error::Result;
use vlcrs_submodules::interface::InterfaceModuleLoader;
use vlcrs_macros::module;
use vlcrs_submodules::{interface::{InterfaceCapability, ThisInterfaceThread}, ModuleArgs};

use vlcrs_messages::{Logger, debug};

pub struct Wasm;

impl InterfaceCapability for Wasm {
    fn open<'a> (
        _this_interface: ThisInterfaceThread<'a>,
        logger: &'a mut Logger,
        _args: &mut ModuleArgs,
    ) -> Result<()> {

        debug!(logger, "Wasm interface module loaded");

        Ok(())
    }
}

module! {
    type: Wasm (InterfaceModuleLoader),
    capability: "interface" @ 0,
    category: INTERFACE_MAIN,
    description: "Wasm Interpreter",
    shortname: "Wasm",
    shortcuts: ["wasmintf"],
}

```

The first major challenge, however, was adding the Extension capability as a submodule of the interface. Unfortunately, the module! macro lacked support for submodules, which required additional development to accommodate this new structure.

The Module stores its information in the ModuleInfo struct, and since submodules are almost like modules, it made sense to include ModuleInfo within the SubmoduleModuleInfo struct. This approach allowed submodules to be parsed using the same logic as modules. However, nested submodules were not permitted, as confirmed by my mentor, so this needed to be handled separately with a clear error message to guide users. The detailed changes required to implement this can be found in this [commit](https://code.videolan.org/videolan/vlc/-/commit/983961ec9976fcb8d4a07797745fd6c4bd562a95).

With this completed, the next step was to include the FFI bindings for the extension module. The logic for this was almost identical to what was done for the interface module, with one key difference: the extension module included control functions that were variadic. This necessitated the introduction of typed callbacks. The merge request related to this work can be found [here](https://code.videolan.org/videolan/vlc/-/merge_requests/5475). With this change merged, the control functions could now be easily defined in Rust.

The Extension Manager submodule can be added using the following syntax:

```rust
module! {
    type: Wasm (InterfaceModuleLoader),
    capability: "interface" @ 0,
    category: INTERFACE_MAIN,
    description: "Wasm Interpreter",
    shortname: "Wasm",
    shortcuts: ["wasmintf"],
    submodules: [
        {
            type: WasmExtensionModule (ExtensionModuleLoader),
            capability: "extension" @ 2,
            category: UNKNOWN,
            description: "Wasm Extension",
            shortcuts: ["wasmextension"],
        }
    ]
}
```
Given the current architecture of the VLC codebase, it's only possible to retrieve a single extensions manager via module_need. If additional managers are required, module_match would need to be used to monitor multiple managers. Because of this limitation, we needed to ensure that our module had a higher priority than the Lua module to allow for proper testing. This is why the priority for our module is set to 2.
